package tcpraw

import (
	"net"

	"golang.org/x/net/bpf"
	"golang.org/x/net/ipv4"
)

// https://www.kernel.org/doc/Documentation/networking/filter.rst
func SetBPFFilterPortByPacketConn(pc *ipv4.PacketConn, port uint32) error {
	return pc.SetBPF([]bpf.RawInstruction{
		{Op: 0x30, Jt: 0, Jf: 0, K: 0x00000009}, // 加载 IP 协议类型 (位于 IP 头偏移 9 字节处)
		{Op: 0x15, Jt: 0, Jf: 6, K: 0x00000006}, //如果不为6，则跳转到指令6(从0开始计数)，即最后一条指令（丢弃包）
		{Op: 0x28, Jt: 0, Jf: 0, K: 0x00000006},
		{Op: 0x45, Jt: 4, Jf: 0, K: 0x00001fff}, //检查分片偏移和标志（如果分片偏移不为0或MF标志为1），则跳转到指令10（即分片包则不匹配）
		{Op: 0xb1, Jt: 0, Jf: 0, K: 0x00000000},
		{Op: 0x48, Jt: 0, Jf: 0, K: 0x00000002},
		{Op: 0x15, Jt: 0, Jf: 1, K: port},
		{Op: 0x6, Jt: 0, Jf: 0, K: 0x00040000},
		{Op: 0x6, Jt: 0, Jf: 0, K: 0x00000000},
	})
}

func SetBPFFilterPort(conn *net.IPConn, port uint32) error {
	RawConn, err := ipv4.NewRawConn(conn)
	if err != nil {
		return err
	}

	/*
		0x28 - ldh 加载半字

		0x15 - jeq 等于跳转

		0x30 - ldb 加载字节

		0x45 - jset 位测试跳转

		0xb1 - 特殊操作（加载IP头长度）

		0x48 - ldh 带索引的加载半字

		0x06 - ret 返回

	*/
	RawConn.SetBPF([]bpf.RawInstruction{
		{Op: 0x30, Jt: 0, Jf: 0, K: 0x00000009}, // 加载 IP 协议类型 (位于 IP 头偏移 9 字节处)
		{Op: 0x15, Jt: 0, Jf: 6, K: 0x00000006}, //如果不为6，则跳转到指令6(从0开始计数)，即最后一条指令（丢弃包）
		{Op: 0x28, Jt: 0, Jf: 0, K: 0x00000006},
		{Op: 0x45, Jt: 4, Jf: 0, K: 0x00001fff}, //检查分片偏移和标志（如果分片偏移不为0或MF标志为1），则跳转到指令10（即分片包则不匹配）
		{Op: 0xb1, Jt: 0, Jf: 0, K: 0x00000000},
		{Op: 0x48, Jt: 0, Jf: 0, K: 0x00000002},
		{Op: 0x15, Jt: 0, Jf: 1, K: port},
		{Op: 0x6, Jt: 0, Jf: 0, K: 0x00040000},
		{Op: 0x6, Jt: 0, Jf: 0, K: 0x00000000},
	})

	return nil
}

/*
使用命令：tcpdump -d "ip and tcp dst port 80"

输出为：
(000) ldh [12]
(001) jeq #0x800 jt 2 jf 10
(002) ldb [23]
(003) jeq #0x6 jt 4 jf 10
(004) ldh [20]
(005) jset #0x1fff jt 10 jf 6
(006) ldxb 4*([14]&0xf)
(007) ldh [x + 16]
(008) jeq #0x50 jt 9 jf 10
(009) ret #262144
(010) ret #0

# tcpdump -dd "ip and tcp dst port 80"
Warning: assuming Ethernet
{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 8, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 6, 0x00000006 },
{ 0x28, 0, 0, 0x00000014 },
{ 0x45, 4, 0, 0x00001fff },
{ 0xb1, 0, 0, 0x0000000e },
{ 0x48, 0, 0, 0x00000010 },
{ 0x15, 0, 1, 0x00000050 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

指令0：加载以太网类型字段（偏移12）
指令1：判断是否为IPv4（0x800），不是则跳转到指令10（返回0）
指令2：加载IP协议字段（偏移23）
指令3：判断是否为TCP（6），不是则跳转到指令10
指令4：加载IP分片信息（偏移20）
指令5：检查分片偏移和标志（如果分片偏移不为0或MF标志为1），则跳转到指令10（即分片包则不匹配）
指令6：加载IP头长度（从偏移14的字节的低4位，然后乘以4）到X寄存器
指令7：从偏移（X+16）处加载半字
指令8：判断加载的值是否等于80（0x50），等于则跳转到指令9（返回262144），否则跳转到指令10（返回0）
指令9：返回262144（0x40000，表示匹配，并截断包为262144字节？实际上，这个返回值是过滤器的返回值，表示匹配成功，并且返回的包长度是262144，但通常我们只关心是否非0）
指令10：返回0（不匹配）

指令格式
BPF 指令格式：{ opcode, jt, jf, k }
opcode: 操作码
jt: 条件为真时跳转的指令数
jf: 条件为假时跳转的指令数
k: 参数或偏移量

逐行分析
第1行: { 0x28, 0, 0, 0x0000000c }
从数据包偏移量 12 字节处加载 2 字节（半字）
检查以太网帧类型字段

第2行: { 0x15, 0, 8, 0x00000800 }
比较是否为 IPv4 协议 (0x0800)
如果不是，跳转到第 10 行（返回 0）

第3行: { 0x30, 0, 0, 0x00000017 }
从偏移量 23 字节处加载 1 字节
检查 IP 头中的协议字段

第4行: { 0x15, 0, 6, 0x00000006 }
比较是否为 TCP 协议 (6)
如果不是，跳转到第 10 行

第5行: { 0x28, 0, 0, 0x00000014 }
从偏移量 20 字节处加载 2 字节
加载 IP 头的分片信息

第6行: { 0x45, 4, 0, 0x00001fff }
检查是否为分片数据包
如果是分片包，跳转到第 10 行

第7行: { 0xb1, 0, 0, 0x0000000e }
从偏移量 14 字节处加载 1 字节，并乘以 4
计算 IP 头长度

第8行: { 0x48, 0, 0, 0x00000010 }
从计算出的 IP 头长度 + 16 字节处加载 2 字节
加载 TCP 目的端口号

第9行: { 0x15, 0, 1, 0x00000050 }
比较目的端口是否为 80 (0x50 = 80)
如果不是，跳转到下一行

第10行: { 0x6, 0, 0, 0x00040000 }
匹配成功，返回 262144 字节（捕获长度）

第11行: { 0x6, 0, 0, 0x00000000 }
匹配失败，返回 0（不捕获）

这个过滤器会捕获所有 IPv4 的 TCP 数据包，且目的端口为 80（HTTP）。



*/
